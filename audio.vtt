WEBVTT

00:00.000 --> 00:05.520
Docker, a tool that can package software into containers that run reliably in any environment.

00:05.520 --> 00:07.400
But what is a container, and why do you need one?

00:07.400 --> 00:11.000
Let's imagine you built an app with COBOL that runs on some weird flavor of Linux.

00:11.000 --> 00:14.000
You want to share this app with your friend, but he has an entirely different system.

00:14.000 --> 00:17.560
So the problem becomes, how do we replicate the environment our software needs on any

00:17.560 --> 00:18.560
machine?

00:18.560 --> 00:21.680
One way to package an app is with a virtual machine, where the hardware is simulated,

00:21.680 --> 00:24.480
then installed with the required OS dependencies.

00:24.480 --> 00:27.160
This allows us to run multiple apps on the same infrastructure.

00:27.200 --> 00:32.160
However, because each VM is running its own operating system, they tend to be bulky and slow.

00:32.160 --> 00:36.680
Now, a Docker container is conceptually very similar to a VM with one key difference.

00:36.680 --> 00:40.440
Instead of virtualizing hardware, containers only virtualize the OS.

00:40.440 --> 00:44.600
Or in other words, all apps or containers are run by a single kernel, and this makes

00:44.600 --> 00:46.840
almost everything faster and more efficient.

00:46.840 --> 00:49.840
There are three fundamental elements in the universe of Docker.

00:49.840 --> 00:52.800
The Docker file, the image, and the container.

00:52.800 --> 00:54.600
The Docker file is like DNA.

00:54.600 --> 00:59.520
It's just code that tells Docker how to build an image, which itself is a snapshot of your

00:59.520 --> 01:03.360
software, along with all of its dependencies down to the operating system level.

01:03.360 --> 01:07.240
The image is immutable, and it can be used to spin up multiple containers, which is your

01:07.240 --> 01:09.680
actual software running in the real world.

01:09.680 --> 01:13.840
Create a Docker file and use from to start from an existing template like Ubuntu.

01:13.840 --> 01:17.640
This base image gets pulled down from the cloud, and you can also upload your own images

01:17.640 --> 01:20.000
to a variety of different Docker registries.

01:20.000 --> 01:23.720
From there, you might want to use run to run a terminal command that installs dependencies

01:23.720 --> 01:24.720
into your image.

01:24.720 --> 01:27.880
You can set environment variables and do all kinds of other stuff, then the last thing

01:27.880 --> 01:31.680
you'll do is set a default command that's executed when you start up a container.

01:31.680 --> 01:35.040
And now, we can create the image file by running the Docker build command.

01:35.040 --> 01:38.880
It goes through each step in our Docker file to build the image layer by layer.

01:38.880 --> 01:42.800
We can then bring this image to life as a container with the Docker run command.

01:42.800 --> 01:47.000
As your app demands more resources, you can run it on multiple machines, multiple clouds,

01:47.000 --> 01:49.520
on-prem, or wherever you want reliably.

01:49.520 --> 01:51.520
This has been Docker in 100 seconds.

01:51.520 --> 01:55.600
If you enjoyed it, make sure to like and subscribe, and stay tuned for more Docker content coming

01:55.600 --> 01:56.800
to this channel soon.

01:56.800 --> 01:58.920
Thanks for watching, and I will see you in the next one.

